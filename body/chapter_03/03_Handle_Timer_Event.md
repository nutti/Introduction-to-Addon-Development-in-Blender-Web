<div id="sect_title_img_3_3"></div>

<div id="sect_title_text"></div>

# タイマのイベントを扱う

<div id="preface"></div>

###### [3-1節](../01_Handle_Mouse_Click_Event.md) と [3-2節](../02_Handle_Keyboard_Event.md) でユーザからの入力イベントを扱いましたが、アドオンでは他にもタイマを設定してある時間が経過した時にイベントを発生させることができます。本節では、タイマから発生するイベントを扱う方法を紹介します。

## 作成するアドオンの仕様

* *3Dビュー* エリアのプロパティパネルの *作業時間計測* から、作業時間計測モードを開始/終了するためのボタンを配置する
* 作業時間計測モードでは、オブジェクトごとの *オブジェクトモード* と *エディットモード* の時間を計測し、*3Dビュー* エリアのプロパティパネルの *作業時間計測* に表示する


## アドオンを作成する

[1-5節](../chapter_01/05_Install_own_Add-on.md) を参考にして以下のソースコードを入力し、ファイル名を ```sample_3-3.py``` として保存してください。


[import](../../sample/src/chapter_03/sample_3-3.py)

## アドオンを使用する

### アドオンを有効化する

[1-5節](../chapter_01/05_Install_own_Add-on.md) を参考に、作成したアドオンを有効化するとコンソールウィンドウに以下の文字列が出力されます。

```sh
サンプル3-3: アドオン「サンプル3-3」が有効化されました。
```

<div id="sidebyside"></div>

|また、プロパティパネルの *作業時間計測* にボタンが配置されます。||
|---|---|


### アドオンの機能を使用する

<div id="process_title"></div>

##### Work

<div id="process"></div>

|<div id="box">1</div>|*3Dビュー* エリアのプロパティパネルの *作業時間計測* に配置されている *開始* ボタンを押すと、アクティブなオブジェクトに対する作業時間の計測が始まります。||
|---|---|---|

<div id="process_sep"></div>

---

|<div id="box">2</div>|作業時間を表示したいオブジェクトをコンボボックスから選択すると、選択したオブジェクトについてオブジェクトモードとエディットモードでの作業時間が表示されます。||
|---|---|---|

<div id="process_sep"></div>

---

<div id="tips"></div>

本節のサンプルでは作業時間計測後のオブジェクトの追加に対応していますが、オブジェクト名の変更には対応していません。  
オブジェクト名を変更すると、名前変更後のオブジェクトが新たに追加されたものとして作業時間が計測されます。


|<div id="box">3</div>|*終了* ボタンを押すと、作業時間の計測が止まります。なお、作業時間を測定した結果は計測終了後も参照することができます。||
|---|---|---|

<div id="process_sep"></div>

---

<div id="process_start_end"></div>

---


### アドオンを無効化する

[1-5節](../chapter_01/05_Install_own_Add-on.md) を参考に有効化したアドオンを無効化すると、コンソールウィンドウに以下の文字列が出力されます。

```sh
サンプル3-3: アドオン「サンプル3-3」が無効化されました。
```


## ソースコードの解説

前節までに説明した内容については、説明を省きます。ソースコードにコメントを残していますので、必要に応じて参照してください。
本節では、タイマイベントを扱う処理と作業時間計測の処理に絞って説明します。


### タイマの登録

タイマイベントを扱うためには、タイマを登録する必要があります。

タイマの登録処理は、次に示す ```handle_add()``` スタティックメソッドで行っています。```handle_add()``` は関数でも問題はありませんが、関連する処理をクラスとして1つにまとめるため、本節のサンプルではスタティックメソッドとして定義しています。

[import:"add_timer", unindent:"true"](../../sample/src/chapter_03/sample_3-3.py)

タイマの登録は、```context.window_manager.event_timer_add()``` 関数で行っています。```context.window_manager.event_timer_add()``` 関数は次に示す引数を取り、戻り値としてタイマのハンドラを返します。戻り値として返されたハンドラはタイマの登録を解除する時に使用するため、クラス変数 ```timer``` に保存します。

|引数|値の意味|
|---|---|
|第1引数|タイマイベントを発生させる間隔を秒で指定|
|第2引数|タイマイベントを登録するウィンドウ|

本節のサンプルでは第1引数に ```0.1``` を指定することで、タイマイベントを0.1秒ごとに発生させています。第2引数には、作業時間の測定を開始した時に押したボタンが存在するウィンドウにタイマイベントを発生させたいため、```context.window``` を指定します。

最後にモーダルモードへ移行する処理を行っていますが、必ずしも ```handle_add()``` スタティックメソッドで行う必要はありません。```handle_add()``` スタティックメソッド自体が ```invoke()``` メソッドから呼び出されているので、[3-1節](01_Handle_Mouse_Click_Event.md) や [3-2節](02_Handle_Keyboard_Event.md) と同様、```invoke()``` メソッドの処理内で ```context.window_manager.modal_handler_add()``` 関数を呼んでモーダルモードへ移行しても良いです。


### タイマの登録を解除

タイマを登録すると、登録を解除するまでタイマイベントを送り続けます。このため、タイマが不要になったら登録を解除する必要があります。

タイマの登録解除処理は、次に示す ```handle_remove()``` スタティックメソッドで行っています。

[import:"remove_timer", unindent:"true"](../../sample/src/chapter_03/sample_3-3.py)

タイマの登録解除は ```context.window_manager.event_timer_remove()``` 関数で行いますが、引数には ```context.window_manager.modal_handler_add()``` 関数の戻り値として返されたタイマのハンドラを渡す必要があります。本節のサンプルでは、タイマのハンドラを保存したクラス変数 ```timer``` を引数に渡しています。

登録解除後のタイマのハンドラは、測定を再開する時のために ```None``` を代入します。


### modalメソッド

[3-1節](01_Handle_Mouse_Click_Event.md) や [3-2節](02_Handle_Keyboard_Event.md) と同様に ```modal()``` メソッドでは、*3Dビュー* エリアの更新と ```modal()``` メソッドの終了判定処理を行います。その後、作業時間の測定結果を保存したデータベースを更新します。

タイマイベントが発生すると、```modal()``` メソッドが呼ばれますが、[3-1節](01_Handle_Mouse_Click_Event.md) や [3-2節](02_Handle_Keyboard_Event.md) で見てきたように、```modal()``` メソッドはキーボードやマウスのイベントが発生した時にも呼ばれます。このため、作業中にマウスやキーボードを使っていると、常にデータベースの更新を行う無駄な処理が発生します。そこで次のようにして、発生したイベントがタイマイベントによるものでなければ、```{'PASS_THROUGH'}``` を返すことでマウスやキーボードからのイベントが発生した時にデータベースを更新しないようにします。

[import:"handle_timer_event", unindent:"true"](../../sample/src/chapter_03/sample_3-3.py)

最後に、```__update_db()``` メソッドを呼びだしてデータベースを更新します。


### データベースの更新

作業時間の測定結果を保存しているデータベースを更新する処理は、```__update_db()``` メソッドで行います。

[import:"update_db", unindent:"true"](../../sample/src/chapter_03/sample_3-3.py)

最初に、すべてのメッシュ型オブジェクトを取得しています。Blender上のオブジェクトには次のような型がありますが、本節のサンプルではメッシュ型のオブジェクトを作業時間の測定対象としています。このため、```obj.type == 'MESH'``` のオブジェクトの名前（```obj.name```）のみを取得しています。

|型|意味|
|---|---|
|```MESH```|メッシュ|
|```CURVE```|カーブ|
|```SURFACE```|サーフェス|
|```META```|メタオブジェクト|
|```FONT```|テキストオブジェクト|
|```ARMATURE```|アーマチュア|
|```LATTICE```|ラティス|
|```EMPTY```|空のオブジェクト|
|```CAMERA```|カメラ|
|```LAMP```|ランプ|
|```SPEAKER```|スピーカー|

取得したメッシュ型オブジェクトの中にデータベースに登録していないオブジェクトが存在する場合は、そのオブジェクトの名前をキーにして作業時間0で登録します。最後にアクティブなオブジェクトについて、前回 ```__calc_delta()``` メソッドが呼ばれた時間（＝タイマイベントが発生した時間）と現在の時間との差分を ```__calc_delta()``` メソッドで取得し、データベースに保存されている累計作業時間に加算します。なお、現在のオブジェクトが *オブジェクトモード* と *エディットモード* のどちらの状態にあるのかは ```active_obj.mode``` により取得することができます。```active_obj.mode``` は次のような値が設定されます。

|値|モード|
|---|---|
|```OBJECT```|オブジェクトモード|
|```EDIT```|エディットモード|
|```SCULPT```|スカルプトモード|
|```VERTEX_PAINT```|頂点ペイント|
|```WEIGHT_PAINT```|ウェイトペイント|
|```TEXTURE_PAINT```|テクスチャペイント|
|```PARTICLE_EDIT```|パーティクル編集|
|```POSE```|ポーズモード|

前回タイマイベントが呼ばれた時からの時間の差分は、```__calc_delta()``` メソッドで取得します。

[import:"calc_delta", unindent:"true"](../../sample/src/chapter_03/sample_3-3.py)

現在時刻を取得するため、```datetime``` モジュールを利用します。本節のサンプルでは処理を単純化するため、タイマイベントが前回発生した時から今回タイマイベントが発生するまでにオブジェクトやモードが変更された場合は、計測した値は無効としています。


## まとめ

タイマのイベントを扱う方法を説明しました。タイマを使うと指定した間隔でイベントを発生させることができるため、定期的に処理を実行するような機能を実現することができます。

[3-1節](01_Handle_Mouse_Click_Event.md) から本節まで3節にわたってイベントを扱う処理を説明しました。次節からは、Blenderが提供する少し特殊なモジュールを使ったアドオンを紹介します。


<div id="point"></div>

### ポイント

<div id="point_item"></div>

* タイマを登録することで、一定間隔でイベントを発生させることができる
* タイマの登録は ```context.window_manager.event_timer_add()``` 関数で行い、不要になったタイマは ```context.window_manager.event_timer_remove()``` 関数で登録を解除する
* タイマイベントが発生すると、```context.window_manager.modal_handler_add()``` の引数に指定したインスタンスの ```modal()``` メソッドが呼び出され、引数 ```event.type``` に ```TIMER``` が設定される
