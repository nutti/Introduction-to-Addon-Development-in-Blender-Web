<div id="sect_title_img_3_2"></div>

<div id="sect_title_text"></div>

# キーボードのキーイベントを扱う

<div id="preface"></div>

###### [3-1節](../01_Handle_Mouse_Click_Event.md) ではマウスのイベントを扱う方法を説明しました。本節ではキーボードのイベントを扱う方法を、サンプルを交えて紹介します。

## 作成するアドオンの仕様

* *3Dビュー* エリアのプロパティパネルの *特殊オブジェクト編集モード* から、特殊オブジェクト編集モードを開始するためのボタンを配置する
* キーボードのキー *Q* が押された時に、特殊オブジェクトを終了する
* 特殊オブジェクト編集モードではキーボードのキー入力に応じて、選択されたオブジェクトに対して以下に示す処理を行う

|キー|処理|
|---|---|
|*T* + *X* + *→*|X軸正方向に平行移動|
|*T* + *X* + *←*|X軸負方向に平行移動|
|*T* + *Y* + *→*|Y軸正方向に平行移動|
|*T* + *Y* + *←*|Y軸負方向に平行移動|
|*T* + *Z* + *→*|Z軸正方向に平行移動|
|*T* + *Z* + *←*|Z軸負方向に平行移動|
|*S* + *X* + *→*|X軸方向に拡大|
|*S* + *X* + *←*|X軸方向に縮小|
|*S* + *Y* + *→*|Y軸方向に拡大|
|*S* + *Y* + *←*|Y軸方向に縮小|
|*S* + *Z* + *→*|Z軸方向に拡大|
|*S* + *Z* + *←*|Z軸方向に縮小|
|*R* + *X* + *→*|X軸周りの正方向に回転|
|*R* + *X* + *←*|X軸周りの負方向に回転|
|*R* + *Y* + *→*|Y軸周りの正方向に回転|
|*R* + *Y* + *←*|Y軸周りの負方向に回転|
|*R* + *Z* + *→*|Z軸周りの正方向に回転|
|*R* + *Z* + *←*|Z軸周りの負方向に回転|


## アドオンを作成する

[1-5節](../chapter_01/05_Install_own_Add-on.md) を参考にして以下のソースコードを入力し、ファイル名を ```sample_3-2.py``` として保存してください。


[import](../../sample/src/chapter_03/sample_3-2.py)

## アドオンを使用する

### アドオンを有効化する

[1-5節](../chapter_01/05_Install_own_Add-on.md) を参考に、作成したアドオンを有効化するとコンソールウィンドウに以下の文字列が出力されます。

```sh
サンプル3-2: アドオン「サンプル3-2」が有効化されました。
```

<div id="sidebyside"></div>

|また、プロパティパネルの *特殊オブジェクト編集モード* にボタンが配置されます。||
|---|---|


### アドオンの機能を使用する

<div id="process_title"></div>

##### Work

<div id="process"></div>

|<div id="box">1</div>|*3Dビュー* エリアのプロパティパネル上の *特殊オブジェクト編集モード* に配置されている *開始* ボタンをクリックすると、特殊オブジェクト編集モードに移行します。この時、コンソールウィンドウに以下のメッセージが出力されます。||
|---|---|---|

```sh
サンプル3-2: 特殊オブジェクト編集モードへ移行しました。
```


<div id="process_sep"></div>

---


<div id="process"></div>

|<div id="box">2</div>|本節サンプルの仕様で書いたように、キーボードのキーの組み合わせによりオブジェクトを並進移動、拡大・縮小、回転することができます。||
|---|---|---|


<div id="tips"></div>

本節で紹介するアドオンにはバグがあります。例えば、*S* + *X* を押している状態で *Y* キーを押すて *→* キーを押すとY軸方向にオブジェクトが拡大されますが、*Y* キーを離して *S* キーと *X* キーのみが押されている状態に戻すと、*→* キーや *←* キーによるオブジェクトの拡大・縮小が行えなくなります。アドオンのソースコードを読めばこのバグの原因はわかると思いますが、説明しやすくするために処理を単純化することを考え、バグをそのまま残しています。  
なお、*X* キーを一度離した後に再度 *X* キーを押し直せば、本来期待する動作である *→* キーや *←* キーによるオブジェクトの拡大・縮小を行えるようになります。


<div id="process"></div>

|<div id="box">3</div>|キーボードの *Q* キーを押し、特殊オブジェクト編集モードを終了します。特殊オブジェクト編集モードを終了すると、コンソールウィンドウに以下のメッセージが表示されます。||
|---|---|---|

```sh
サンプル3-2: 通常モードへ移行しました。
```


<div id="process_start_end"></div>

---


### アドオンを無効化する

[1-5節](../chapter_01/05_Install_own_Add-on.md) を参考に有効化したアドオンを無効化すると、コンソールウィンドウに以下の文字列が出力されます。

```sh
サンプル3-2: アドオン「サンプル3-2」が無効化されました。
```


## ソースコードの解説

変数名などの細かい部分が異なるところはありますが、オペレータクラスの ```modal()``` メソッドの処理を除いて [3-1節](01_Handle_Mouse_Click_Event.md) の内容とほとんど同じです。このため本節では、オペレータクラス ```SpecialObjectEditMode``` の ```modal()``` メソッドの処理内容について説明します。

### modal()メソッド

```modal()``` メソッドの最初の処理である、*3Dビュー* エリアの更新処理までは [3-1節](01_Handle_Mouse_Click_Event.md) と同様です。

#### モーダルモード終了処理

本節のサンプルでは、モーダルモードを終了するためにキーボードの *Q* キーを押す必要があります。この処理を実現するために、キーボードのキーイベントが発生した時に ```modal()``` メソッドの引数 ```event``` のイベント情報を利用します。*Q* キーが押された時にモーダルモードを終了するためのコードを以下に示します。

[import:"exit_modal_mode", unindent:"true"](../../sample/src/chapter_03/sample_3-2.py)

キーイベント発生時の変数 ```event``` には、以下のメンバ変数が格納されています。

|メンバ変数|意味|
|---|---|
|```type```|イベントが発生したキーの識別子|
|```value```|イベントの内容|

本節のサンプルでは、*Q* キーが押されたイベントが発生した場合、```event.type``` には ```Q``` 、```event.value``` に ```PRESS``` が格納されていることを利用しています。特殊オブジェクト編集モード時に ```True``` を設定する ```props.is_special_mode``` を ```False``` にして ```{'FINISHED'}``` を返すことでモーダルモードを終了し、特殊オブジェクト編集モードを終了します。

#### 特殊オブジェクト編集モード時のキー入力状態の確認

特殊オブジェクト編集モードでは、利用するキーの状態を確認しオブジェクトの変形処理を実行する必要があります。次に示すコードにより、利用するキーの状態を確認します。

[import:"check_key_state", unindent:"true"](../../sample/src/chapter_03/sample_3-2.py)

コード量を少なくするために少し込み入ったことを行っていますので、順を追って説明します。
最初に、```ev_key_list``` 変数を宣言しています。```ev_key_list``` 変数の要素については、ソースコードのコメントを参照してください。

第2要素には、次に示す状態を保持するためのインスタンス変数名を指定しています。

|変数|意味|
|---|---|
|```edit_type```|変形の種類（並進移動、拡大・縮小、回転）|
|```edit_axis```|変形を適用する軸（X、Y、Z）|
|```edit_opt```|変形の方向（正方向、負方向）|

インスタンス変数の定義は、クラスがインスタンス化される時に実行される ```__init__()``` メソッドで行います。

[import:"define_instance_variable", unindent:"true"](../../sample/src/chapter_03/sample_3-2.py)

各インスタンス変数には、```Enum``` クラスにより定義された、状態遷移を示す列挙値が入ります。
クラスがインスタンス化された直後は、どの状態にも含まれていないため ```NONE``` を指定しています。インスタンス変数は、```ev_key_list``` の各要素について、次に示す ```__change_state()``` 関数を呼び出す事更新します。

[import:"change_state", unindent:"true"](../../sample/src/chapter_03/sample_3-2.py)

```__change_state()``` 関数は、第1引数に指定された ```event.value``` が ```PRESS``` である場合は第2引数に指定した値、```PRESS``` 以外である場合は第3引数に指定した値を戻り値として返却します。
このため、```__change_state()``` 関数を実行することで、```ev_key_list``` の要素の第1要素に指定されたキーについて ```PRESS``` イベントが発生した時は、第3要素で指定された列挙値が設定されます。一方で ```PRESS``` イベント以外のイベントが発生した時は、第4要素で指定された列挙値が設定されます。

状態を更新した結果、状態を示す列挙値が ```NONE``` であるインスタンス変数が1つでも存在した場合は、```{'RUNNING_MODAL'}``` を返すことによってオブジェクト変換処理は行いません。

[import:"check_state", unindent:"true"](../../sample/src/chapter_03/sample_3-2.py)

#### オブジェクトに変形処理を適用

オブジェクトを変形する状態であるならば、インスタンス変数の値を確認してオブジェクトの変形処理を行います。ソースコードにコメントを追加しているので、具体的な処理内容についてはソースコードを参照してください。

[import:"apply_transformation", unindent:"true"](../../sample/src/chapter_03/sample_3-2.py)

なお、オブジェクト変形処理のためにBlenderのAPIを使用しています。こちらもソースコードのコメントにAPIの簡単な説明と引数の説明を書きましたので、参考にしてください。

#### modal()メソッドの戻り値

最後に、```modal()``` メソッドの戻り値を ```{'RUNNING_MODAL'}``` で返していますが、これは特殊オブジェクトモード時にキーを押した時にBlenderへ処理を伝搬しないようにするためです。仮にこの部分を ```{'PASS_THROUGH'}``` としてしまうと、Blenderにもキーイベントが発生してしまいます。例えば、Blenderがオブジェクトの拡大・縮小機能に割り当てている *S* キーを押した場合、Blenderの機能が起動してしまいます。

## まとめ

本節では、キーボードのキーイベントを扱う方法を紹介しました。[3-1節](01_Handle_Mouse_Click_Event.md) のサンプルと比較すると、マウスのイベントとキーボードのイベントを扱うためには ```modal()``` メソッド、または ```invoke()``` メソッドに渡されてくるイベント情報が格納された引数を用いる点で同じであることを理解していただけたのではないでしょうか。

通常のアドオンの処理と異なり、ユーザからのイベントを扱ってインタラクティブな機能を提供することは、これまでに紹介してきた ```execute()``` メソッドを単に実行する処理と比べて処理が複雑になりがちでバグも発生しやすくなります。しかしキーボードやマウスのイベントを適切に扱うことができれば、アドオンで実現できることがかなり広がります。


<div id="point"></div>

### ポイント

<div id="point_item"></div>

* ```modal()``` メソッドや ```invoke()``` メソッドの引数に渡されてくるイベント情報を用いることにより、キーボードのキーイベントを扱うことができる
* ユーザのイベントを扱うことでインタラクティブな機能を提供できる反面、機能を実現するための処理が複雑化する傾向がある
