---
pagetitle: 2-6. アドオンのソースコードを<br>複数ファイルへ分割する
subtitle: 2-6. アドオンのソースコードを<br>複数ファイルへ分割する
---

アドオンへ機能を追加し続けると、やがてソースコードのサイズが肥大化していきます。
ソースコードが肥大化することで管理が大変になってきたら、ソースコードを複数ファイルに分割することを検討しましょう。
本節では、アドオンのソースコードを複数のファイルへ分割する方法を紹介します。


# ソースコードを複数ファイルに分割するメリット

前節までに紹介してきたサンプルアドオンのソースコードは、単一のファイルで構成されていました。
これまでのサンプルアドオンは、非常に単純な機能しか持たないアドオンであったため、ソースコードの行数も比較的少なく、単一のファイルでも問題なく扱うことができました。
しかし、本格的なアドオンは、本書で紹介しているアドオンよりも複雑な処理になる傾向があります。
複雑で規模が大きい処理の全てを単一のファイルに書くと、あとでソースコードを修正したいときに修正箇所を見つけるのが大変です。

一般的に物事を分割して考えることは、複雑なことを理解するときの助けになります。
アドオンの開発においても同じことが言え、ソースコードを複数のファイルに分割することで管理しやすくなります。
例えば、あとからソースコードを修正するときに、単一のファイルで構成されているとファイル全体を見る必要があるのに対し、ファイルが適切に分割されていれば、関係のないファイルのソースコードを見る必要がなくなるため、目的の修正箇所を早く見つけることができます。


# 作成するアドオンの仕様

本節では、次に示すアドオンを作成します。

* [2-2節](../chapter_02/02_Register_Multiple_Operator.html) で紹介したサンプルアドオンと同じ機能を持つ
* *[オブジェクト]* > *[X軸正方向へ並進移動]* の処理と *[オブジェクト]* > *[X軸負方向へ並進移動]* の処理を、複数のファイルに分割して記述する


# アドオンを作成する

[1-2節](../chapter_01/02_Use_Blender_Add-on.html) で説明したBlenderアドオン用フォルダに、ディレクトリ名 `sample_2-6` のディレクトリを作成します。
[1-5節](../chapter_01/05_Install_own_Add-on.html) を参考にして次のソースコードを入力し、作成したディレクトリの下にファイル名をそれぞれ `__init__.py` , `forward_object.py` , `backward_object.py` として保存してください。


## \_\_init\_\_.py

[@include-source pattern="full" filepath="chapter_02/sample_2-6/__init__.py"]


## forward_object.py

[@include-source pattern="full" filepath="chapter_02/sample_2-6/forward_object.py"]


## backward_object.py

[@include-source pattern="full" filepath="chapter_02/sample_2-6/backward_object.py"]


# アドオンを使用する

## アドオンを有効化する

[1-5節](../chapter_01/05_Install_own_Add-on.html) を参考に作成したアドオンを有効化すると、コンソールウィンドウに次の文字列が出力されます。

```
サンプル 2-6: アドオン『サンプル 2-6』が有効化されました。
```


## アドオンの機能を使用する

アドオンの機能は、[2-2節](../chapter_02/02_Register_Multiple_Operation_Classes.html) で紹介したサンプルと同じ機能ですので、ここでは説明を省きます。


## アドオンを無効化する

[1-5節](../chapter_01/05_Install_own_Add-on.html) を参考にして有効化したアドオンを無効化すると、コンソールウィンドウに次の文字列が出力されます。

```
サンプル 2-6: アドオン『サンプル 2-6』が無効化されました。
```


# ソースコードの解説

## モジュールとパッケージ

ソースコードの解説に入る前に、Pythonのモジュールとパッケージの概念について説明します。

Pythonでは、クラスや関数、変数が定義された1つのファイルをモジュールといいます。
ソースコード内でモジュールをインポートすることによって、そのモジュールで定義されたクラスや関数、変数が使用可能となります。

一方、複数のモジュールを1つにまとめたものをパッケージといいます。
Pythonでパッケージを作成するためには、ディレクトリを作成し、その配下にファイル `__init__.py` とパッケージ化するモジュール一式を置きます。
Pythonで一般的にパッケージを作る場合、`__init__.py` は空のファイルでもよいですが、Blenderでパッケージを作る場合は、後述する特別な処理を定義する必要があります。

モジュール名はスクリプトのファイル名、パッケージ名は `__init__.py` とモジュール一式をまとめたディレクトリ名となります。
このことを踏まえると、本節のサンプルアドオンにおけるモジュールとパッケージの関係は、「sample_2-6パッケージには、forward_objectモジュールとbackward_objectモジュールが含まれる」となります。


## \_\_init\_\_.pyとは

本節で作成したサンプルアドオンのソースコードは、3つのファイルから構成されます。
3つのファイルのうち最も重要なファイルは、`__init__.py` です。
`__init__.py` には、アドオン有効化時に実行される処理やモジュールの読み込み処理を定義します。
（本節のサンプルでは、forward_objectモジュールとbackward_objectモジュールを読み込む処理を定義します。）

一般的に `__init__.py` には、パッケージインポート時に呼び出される処理を定義することになっています。
`register` 関数や `unregister` 関数が定義され、これらの関数がアドオンの有効化/無効化時に呼び出されることから、アドオンの有効化処理は、Blender上でのパッケージのインポート処理と同様であると考えることができます。


### モジュールのインポート

モジュールのインポートは、bpyモジュールを読み込むときと同様、`import` 指示により行います。

```python
import forward_object
import backward_object
```

しかし、上記のコードを実行すると、アドオン有効化時にforward_objectとbackward_objectが見つからないというエラーが発生します。
これは、Blenderがforward_objectモジュールとbackward_objectモジュールの場所を知らないからです。

Blenderに対して、forward_objectモジュールとbackward_objectモジュールの場所を知らせるために、次のように書き換えます。

```python
from . import forward_object
from . import backward_object
```

`from .` を追加したことにより、ファイル `__init__.py` が置かれたディレクトリ、つまり自身のパッケージの中から2つのモジュールforward_objectとbackward_objectを探すようになります。
上記のコードで、アドオン有効化時のエラーは出力されなくなりました。
しかし、もう1つやるべきことがあります。

[1-4節](../chapter_01/04_Understand_Install_Uninstall_Update_Add-on.html) では、Blenderの機能である『Reload Scripts』機能を用いて、Blenderを再起動せずにアドオンをアップデートする方法を紹介しました。
しかし、『Reload Scripts』機能を使っても、アドオンをアップデートできない場合があります。

結論から言うと、『Reload Scripts』機能を使ったときに、`__init__.py` の処理の中で、インポートしているモジュールの再読み込みに失敗していることが原因です。
`from  . import ...` を用いて、モジュールの再読み込みができると思う人もいるかもしれませんが、すでにインポートされているモジュールに対するインポート処理は、無視されてしまうことに注意が必要です。

この問題に対応するため、次のようにインポート処理を書き換える必要があります。

[@include-source pattern="partial" filepath="chapter_02/sample_2-6/__init__.py" block="import_moudle"]

上記の処理を簡単に説明します。
最初のif文では、bpyモジュールがすでにインポートされているかを判定します。
インポートされていなければ、Blender起動後に初めてアドオンが読み込まれたと判定し、関連するモジュールをインポートします。

一方、bpyモジュールがすでにインポートされていれば、Blenderが起動してから2回目以降の読み込みであると考えることができます。
このときは、impモジュールを用いて、すでにインポートされているモジュールを再度読み込みます。
2回目以降の読み込みと判定されるのは、『Reload Scripts』機能によりアドオンが再度読み込まれたときに限定されるため、これは正しく動作します。

なお、bpyモジュールのインポート処理の定義は、このif文判定のあとでなければなりません。
仮に、bpyモジュールのインポート処理を、if文判定の前に書いてしまうと、最初のif文の条件式が真と判定されてしまい、期待した動作になりません。


### グローバル変数bl_infoの作成

ファイル `__init__.py` には、グローバル変数 `bl_info` を定義する必要があります。
`bl_info` については、[2-1節](../chapter_02/01_Basic_of_Add-on_Development.html) ですでに説明しているため、ここでは説明を省略します。


### アドオン有効化・無効化時の処理

アドオンの有効化・無効化時に呼ばれる `register` 関数と `unregister` 関数についても、`__init__.py` に定義する必要があります。

`register` 関数と `unregister` 関数に定義した処理は、[2-1節](../chapter_02/01_Basic_of_Add-on_Development.html) で説明した内容とほぼ同じですが、1点異なることがあります。

`register` 関数や `unregister` 関数の処理内で、`bpy.types.VIEW3D_MT_object.append` メソッドの引数に渡す `menu_fn` 関数を見てください。
`menu_fn` 関数の中で `self.layout.operator` メソッドが呼ばれているのは同じですが、引数に渡すクラス名の前にモジュール名が追加されています。
bpyモジュールと同様に、forward_objectやbackward_objectもモジュールであるため、モジュール内のクラスや関数などにアクセスするためには、モジュール名を指定してあげる必要があります。


## forward_object.py、backward_object.py

`forward_object.py` には `SAMPLE26_OT_ForwardXObject` クラス、`backward_object.py` には `SAMPLE26_OT_BackwardXObject` クラスが定義されています。
ソースコードの内容は、[2-1節](../chapter_02/01_Basic_of_Add-on_Development.html) と同じであるため、ここでは説明を省略します。


# まとめ

アドオンのソースコードを、複数のファイルに分割する方法を紹介しました。

ソースコードは、規模が大きくなるにつれて管理しにくくなる傾向があるため、ある程度ソースコードの規模が大きくなってきたら、複数のファイルに分割することを検討すべきです。
ソースコードを分割する単位は、行数や機能などさまざまですが、筆者はアドオンを機能単位に分割するように心がけています。
これにより、機能にちなんだファイル名をつけることができるようになります。
また、機能ごとにモジュールが分割されることで、特定の機能を修正したいときに目的のソースコードを素早く見つけることができます。


## ポイント

* Pythonでは、クラスや関数、変数が定義された1つのファイルをモジュールという
* Pythonでは、複数のモジュールを1つにまとめたものをパッケージという
* Pythonでパッケージを作成するためには、ディレクトリ配下に `__init__.py` とパッケージ化するモジュール一式を置く必要がある
* `__init__.py` には、アドオン有効化時に実行される処理やモジュールの読み込み処理を定義する
* アドオンのソースコードを複数のファイルに分割する場合は、『Reload Scripts』機能への対応を忘れないようにしよう
* ソースコードの行数が大きくなると管理しにくくなる傾向があるため、ソースコードの規模が大きくなってきたら複数のファイルに分割することを検討しよう
